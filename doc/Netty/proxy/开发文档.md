# 概述
guardian的所有业务模块加载完全基于JDK的服务提供者框架（Service Provider Interface），guardian模块开发者只需要遵循JDK的服务提供者框架规范，
可以任意的增加子模块,实现自己需要的相应的业务功能。其模块加载工作由guardian框架完成，模块开发者不需要关心其细节。

# guardian模块开发基础

guardian项目底层基础架构为netty。要进行guardian的业务模块必须理解Netty的Channel、ChannelHandler、ChannelPipeline、ByteBuf等接口。

netty有两种类型的ChannelHandler:ChannelInboundHandler（入站）、ChannelOutboundHandler（出站）。一般来说，业务模块需要在Channel读消息时
进行相关的业务处理，则需要定义实现ChannelInboundHandler接口的业务ChannelHandler；如果业务模块需要在Channel写消息时进行进行相关的业务处理，
则需要实现ChannelOutboundHandler接口的业务ChannelHandler。如果既要在读消息又要在写消息时进行业务处理，那么可以实现ChannelDuplexHandler类型（读写双向）
接口的业务ChannelHandler。

所有的业务Handler都一定顺序放在Channel的ChannelPipeline中，其执行顺序如下图：
![](channelPipeline.png)

# guardian模块的加载

guardian项目最核心、最基础、必备的模块为代理转发模块（proxy），该模块为默认加载的。
假定为了实现grpc的代理转发，需要添加http2模块；为了实现ssl加密传输，需要开启ssl模块。其模块的加载顺序变为：
ssl -> http2 -> proxy。为什么是按照如此的顺序呢？因为我们的实际业务本身就是如此要求的，先经过ssl，然后经过http2模块实现与client端交互、http2帧解析，
最后到proxy模块转发到server端，实现最基础的代理转发功能。

如果需要新增一个业务模块(moduleA)，那么其模块的加载顺序看起来应该为：

```ssl -> http2 -> moduleA -> proxy```

moduleA必须放在http2模块后，因为moduleA模块必须知道header帧内容是什么，然后才能做相关的业务处理。

如果需要新增三个业务模块moduleA、moduleB、moduleC，moduleA、moduleB、moduleC的具体顺序必须由业务开发人员定义。

# guardian模块开发


所有的guardian模块都必须实现GuardianModule接口

```java
public interface GuardianModule {
    // 设置配置
    void setGuardianContainer(ConnectionPools connectionPools, ProxyContainer proxyContainer);

    // 是否激活该ChannelHandler
    boolean isActivate();

    // 获取ChannelHandler
    ChannelHandler getChannelHandler(SocketChannel socketChannel);
}
```

其开发步骤如下：
1. 确定业务模块在guardian项目中的加载顺序，并配置文件（starter模块中resources/guardian.yml）中添加该模块
2. 新增业务模块
（1）编写业务处理的handler，该handler可以是netty的任何一种ChannelHandler的实现类；
（2）编写从配置文件中获取的配置选项类；
（3）编写GuardianModule的实现类；
 (4) 在resources/META-INF/services目录中添加com.test.guardian.core.GuardianModule文件，文件中的内容为GuardianModule的实现类的完整类路径；

# guardian模块开发案例
假定我们需要开发router模块,其步骤如下：
1. 在guardian项目中添加router模块


 (1) 编写业务处理的handler

```java
public class RouterHandler implements ChannelInboundHandler{

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        // 此处定义自己的业务代码
        if(msg instanceof Http2HeadersFrame){
            Http2HeadersFrame headersFrame = (Http2HeadersFrame)msg;
            String path = headersFrame.headers().path();
            if(path.equals("...")){
                // 业务代码
                ... ...

            }
        }
    }
}
```

（2）编写从配置文件读取参数的类RouterOption

```
public class RouterOption {
    private String param1;

    private int param2;

    public String getParam1() {
        return param1;
    }

    public void setParam1(String param1) {
        this.param1 = param1;
    }

    public int getParam2() {
        return param2;
    }

    public void setParam2(int param2) {
        this.param2 = param2;
    }
}

```

 (3) 编写GuardianModule的实现类RouterModule

```java
public class RouterModule implements GuardianModule{
    // router配置
    private RouterOption routerOption;
    @Override
    public void setGuardianContainer(ConnectionPools connectionPools, ProxyContainer proxyContainer) {
        // 获取router模块的配置参数
        routerOption = proxyContainer.get(RouterOption.class);
    }

    @Override
    public boolean isActivate() {
        // 是否激活，根据routerOption确定是否启用该模块
        return isActivateInternal(routerOption);
    }

    private boolean isActivateInternal(){
        // 是否激活的业务代码
        ... ...
    }

    @Override
    public ChannelHandler getChannelHandler(SocketChannel socketChannel) {
        // 设置本模块的业务处理handler为RouterHandler
        return new RouterHandler();
    }
}
```


(4) 在resources/META-INF/services目录中添加com.test.guardian.core.GuardianModule文件, 文件中的内容为：
   ```com.test.guardian.http2.Http2Module ```

2. 在配置文件(starter模块中resources/guardian.yml)中添加新开发的模块名：router，注意router刚好对应于实现类RouterModule的名字前匹配

3. 在配置文件中guardian.yml配置该模块对应的参数选项；





